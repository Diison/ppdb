PPDB
====

This module contains functions for reading the `Paraphrase Database (PPDB)
<http://paraphrase.org/#/>`_, an automatically generated database of paraphrases
in different languages.

Long story short, PPDB was generated by selecting words and phrases that were
translated in the same way to English. Thus, a known problem with it is that
many entries are not *real* paraphrases, but variations in gender, number, case
or other morphological subtleties not present in English.

This package provides both an easy interface to use the PPDB in your code as
well as entry points to define filter functions.

Filters
-------

Currently, there are only implemented filters for Portuguese. They discard
paraphrase rules that only change gender or number, as well as leading or
trailing articles and commas in the rules.

Here is an example of a filter function that you can implement:
::

    def my_filter(lhs, rhs):
        """
        Return True if the pair should be filtered out (it is not a relevant
        paraphrase); otherwise return False.
        """
        stripped_lhs = strip_suffix(lhs)
        stripped_rhs = strip_suffix(rhs)

        if stripped_lhs == stripped_rhs:
            return True

        return False

    def strip_suffix(word):
        # language-specific logic

Then you call ``ppdb.load_dict`` with it:
::

    import ppdb
    ppdb_rules = ppdb.load_ppdb(path, my_filter)

Loading a PPDB file and filtering pairs can be time consuming, especially for
the larger ones. For this reason, I recommend using pickle to serialize a
TransformationDict after it is created, so the next time it can be loaded much
faster. If you pass a path ending in ``.pickle``, ``ppdb.load_ppdb()`` will just
load it and ignore the filtering logic.

If you want to use the existing Portuguese filters, import ``ppdb_pt``:
::

    from ppdb import ppdb_pt
    ppdb_rules = ppdb.load_ppdb(path)
    
And if you happen to write filter functions for another language, please submit 
a pull request!

Singleton Usage
---------------

Once the dataset is read, ``ppdb`` stores the same object it returns as a
singleton. You can then call ``ppdb.get_rhs()`` to get the RHS of a given LHS.

In order to replace the singleton object inside the module, call
``ppdb.load_ppdb()`` with ``force=True``.

TransformationDict
------------------

The paraphrase rules are stored in a data structure called TransformationDict,
which is a subclass of Python's built-in ``dict``. The TransformationDict
returned by ``load_ppdb`` maps the left-hand side (LHS) of the rules into the
righ-hand sides (RHS).

The values stored by the dictionary are tuples with the set of RHS for that LHS
and another TransformationDict with possible continuations of the LHS for other
RHS.

Confused? Let's start simple. Suppose there are two paraphrase rules:
::

    A -> X
    A B -> Y

A TransformationDict storing it would look like this:
::

    >>> ppdb_rules
    {'A': ({('X',)}, {'B': ({('Y',)}, {})})}
    >>> rhs, more_rules = ppdb_rules['A']
    >>> rhs
    {('X',)}  # a set with the only RHS for "A"
    >>> more_rules
    {'B': ({('Y',)}, {})}  # more nested stuff
    >>> rhs, more_rules = ppdb_rules[('A', 'B')]
    >>> rhs
    {('Y',)}  # a set with the only RHS for "A B"
    >>> more_rules
    {}

If you only want the RHS for a specific LHS, you can use ``get_rhs()``, like in
the singleton usage:
::

    >>> ppdb_rules.get_rhs('A')
    {('X',)}
